CRM DATA ANALYST AGENT - TECHNICAL DOCUMENTATION
Version: 2.1 (Enhanced Hybrid Architecture)
Status: Production-Ready / Verified
Date: February 18, 2026

1. PROJECT OVERVIEW
The CRM Data Analyst Agent is an autonomous AI system designed to answer complex business questions by querying a fragmented SQLite database. Unlike traditional text-to-SQL tools that struggle with ambiguous schemas and multi-step reasoning, this agent employs a Hybrid Architecture that combines the reliability of a deterministic pipeline with the reasoning capabilities of a Large Language Model (LLM).

Core Capabilities:
- Complex Reasoning: Can deduce relationships between disconnected tables (e.g., aggregating monthly orders vs. pipeline deals).
- Self-Correction: Detects and fixes SQL errors automatically.
- Ambiguity Resolution: Clarifies user intent before generating code.
- Business Logic Enforcement: Strictly adheres to business rules (e.g., "Won deals come from sales_pipeline, not monthly tables").

--------------------------------------------------------------------------------

2. ARCHITECTURAL EVOLUTION

The system evolved through three distinct phases to address specific challenges in reliability and accuracy.

Phase 1: Classic Pipeline (crm_agent_classic)
The "Assembly Line" Approach.
- Design: A rigid SequentialAgent pipeline of 8 specialized subagents.
- Strength: High control and predictability.
- Weakness: The sql_architect was a "dumb" text generator. It often failed on complex queries because it couldn't "think" about schema relationships or test its own SQL before execution.

Phase 2: Smart Agent (crm_agent)
The "Monolithic Brain" Approach.
- Design: A single LlmAgent offering gemini-2.5-flash with a BuiltInPlanner.
- Strength: Highly autonomous; could reason through problems dynamically.
- Weakness: Prone to hallucination. Without the strict guardrails of the pipeline, it would sometimes invent columns or ignore business rules.

Phase 3: Hybrid Agent (Current System)
The "Best of Both Worlds" Approach.
- Design: We retained the robust Phase 1 Pipeline but surgically replaced the weak sql_architect with a Phase 2-style Planner Agent.
- Result: The agent now follows a strict process (Pipeline) but calculates the SQL using advanced reasoning (Planner), resulting in high accuracy and reliability.

--------------------------------------------------------------------------------

3. HIGH-LEVEL ARCHITECTURE (CURRENT SYSTEM)

The system uses a Sequential Pipeline architecture where data flows through a series of specialized agents.

Major Components:
1. Orchestrator (SequentialAgent): Manages the end-to-end flow.
2. Specialist Subagents:
   - Schema Extractor: Loads database structure context.
   - Query Analyst: Translates vague questions into technical requirements.
   - Smart SQL Architect (Hybrid): The core intelligence. Reasons about data and generates verified SQL.
   - SQL Loop: A self-healing execution loop (Validator -> Executor -> Verifier -> Corrector).
   - Business Analyst: Formats the final answer for the user.

--------------------------------------------------------------------------------

4. ARCHITECTURE DIAGRAM (Text Representation)

User Query
    |
    v
Orchestrator (SequentialAgent)
    |
    +--> Schema Extractor (Loads DB Context)
    |
    +--> Query Analyst (Clarifies Intent)
    |
    +--> HYBRID CORE: Smart SQL Architect (LlmAgent + Planner)
    |       |-- Reasoning & Self-Testing
    |       +-- Outputs SQL
    |
    +--> SQL LOOP (Self-Healing Execution)
    |       |--> Validator (Syntax Check)
    |       |--> Executor (Run Query)
    |       |--> Verifier (Check Data)
    |       +--> Corrector (Fix Errors if any fail)
    |
    v
Business Analyst (Final Response)

--------------------------------------------------------------------------------

5. TECHNOLOGY STACK

- Framework: google-adk (Agent Development Kit)
  Reasoning: Provides robust SequentialAgent and LlmAgent abstractions.

- Model: gemini-2.5-flash
  Reasoning: Selected for high reasoning capability ("thinking" mode) and low latency.

- Planner: PlanReActPlanner
  Reasoning: Enables the SQL Architect to think step-by-step ("Plan-Reason-Act") before acting.

- Database: SQLite
  Reasoning: Lightweight, distinct file-based structure ideal for testing fragmented schemas.

--------------------------------------------------------------------------------

6. SYSTEM WORKFLOW (DETAILED)

1. Schema Extractor: Connects to the DB, extracts CREATE TABLE statements, and injects them into the session context.

2. Query Analyst: Analyzes the user's natural language request. It clarifies ambiguities (e.g., "top accounts" -> "top accounts by revenue") and sets the strategy.

3. Smart SQL Architect (Hybrid Step):
   - Receives the requirement.
   - Plans: Decides which tables are needed (sales_pipeline vs monthly_orders).
   - Reasons: Determines join logic (e.g., handling one-to-many relationships).
   - Tests: Can internally run run_sql_query to verify assumptions.
   - Outputs: Produces a high-confidence SQL query.

4. SQL Loop:
   - Validator: Statistically checks SQL syntax.
   - Executor: Runs the query against the production DB (Read-Only).
   - Verifier: Checks if rows were returned.
   - Corrector: If any step fails, this agent (LLM) analyzes the error and regenerates the SQL.

5. Business Analyst: Takes the raw JSON result and the original question to formulate a human-readable text response.

--------------------------------------------------------------------------------

7. DATABASE DESIGN & REASONING CHALLENGES

The database is intentionally designed to be fragmented to test the agent's logical capabilities.

Key Challenges:
- Duplicate Data Sources: Revenue exists in both sales_pipeline (deal-based) and 10 separate monthly_order tables (order-based).
  Golden Rule: "Use sales_pipeline for deal stages (Won/Lost). Use monthly tables for time-series analysis. NEVER join them."

- Split Account Info: Basic info is in accounts_3, but location data is in intl_accounts.

- Structure Mismatches: International accounts have office_location, domestic ones do not (implying 'N/A').

Strategy: The Smart SQL Architect is explicitly instructed on these rules and uses its reasoning planner to select the correct path purely based on the question context.

--------------------------------------------------------------------------------

8. KEY DESIGN DECISIONS

Hybrid Architecture (Sequential + Planner)
We chose to embed an LlmAgent (Planner) inside a SequentialAgent (Pipeline).
Why? A purely sequential pipeline is too rigid for complex SQL generation. A purely autonomous agent is too unpredictable. The hybrid approach gives us structured control flow with intelligent execution steps.

PlanReActPlanner
We switched the sql_architect to use PlanReActPlanner.
Why? The reasoning trace (Plan -> Thought -> Act) allows us to debug why the agent chose a specific table or join. It also allows the agent to self-correct ("Wait, I shouldn't join these tables") before generating the final SQL.

The "SQL Loop" Pattern
We implemented a dedicated feedback loop for SQL execution.
Why? SQL generation is prone to minor syntax errors. Instead of failing the whole request, the loop allows a specialized "Corrector" agent to fix the SQL based on the specific error message (e.g., "no such column") and retry immediately.

--------------------------------------------------------------------------------

9. SETUP & USAGE GUIDE

Prerequisites:
- Python 3.10+
- Google Cloud Project with Vertex AI API enabled
- Valid GOOGLE_API_KEY environment variable

Running the Agent:
1. Open terminal in project root.
2. Run: `adk web`
3. Open browser to http://localhost:8080/
4. Select Agent: `crm_agent_classic` (This is the Hybrid Agent)

Example Queries to Try:
- Simple: "What is the total revenue from Won deals?"
- Strategic: "Who are the top 3 accounts by revenue and where are their offices located?"
- Trend: "Show me the monthly revenue trend for 2017."
- Complex: "Which sales agent manages the most 'Won' deals in the West region?"

--------------------------------------------------------------------------------

10. TROUBLESHOOTING GUIDE

Common Issue: "No data found"
- Cause: The query might be too strict (e.g., misspelled account name).
- Solution: Ask the agent to list available accounts first.

Common Issue: "SQL Syntax Error"
- Behavior: The agent will automatically retry up to 3 times. You will see "SQL Corrector" appearing in the trace.
- Solution: Usually self-healing. If persistent, verify schema names.

Common Issue: "Hallucinated Column"
- Behavior: Agent tries to query a column that doesn't exist.
- Solution: The Smart Architect (Hybrid) minimizes this, but if it happens, the SQL Loop will catch the error and the Corrector will fix it by removing the invalid column.

--------------------------------------------------------------------------------

11. RELIABILITY & DEBUGGING STRATEGY

Why is this stable?
1. Deterministic Flow: The high-level steps (Context -> Code -> Data -> Answer) never change.
2. Reasoned SQL: The SQL step is no longer a guess; it's a planned output derived from schema analysis.
3. Self-Correction: The SQL Loop acts as a safety net. If the Smart Architect does make a mistake, the Corrector catches it.

Verified Success Scenario:
- Query: "Top 3 accounts by revenue with sales team."
- Complexity: Requires joining aggregated revenue data with multi-value text fields (sales teams).
- Outcome: The agent correctly identified the need for sales_pipeline (revenue), sales_teams_1 (teams), and intl_accounts (location), and acted to aggregate the one-to-many team relationship.
